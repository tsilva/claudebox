# =============================================================================
# GitHub Actions CI Workflow
# =============================================================================
#
# This file defines a Continuous Integration (CI) pipeline that runs
# automatically on GitHub's servers whenever code is pushed or a pull request
# is opened. GitHub Actions looks for workflow files in .github/workflows/.
#
# The file uses YAML format (a human-readable data format based on indentation,
# similar to Python). Keys followed by colons define properties; dashes define
# list items.
# =============================================================================

# "name" sets the display name shown in the GitHub Actions tab of the repository.
# This is purely cosmetic — it has no effect on behavior.
name: CI

# "on" defines WHEN this workflow should run (the trigger events).
# Without this, the workflow would never execute.
on:
  # Run when commits are pushed directly to the "main" branch.
  push:
    # "branches" is a list of branch names that trigger the workflow.
    # Using [main] means only pushes to "main" trigger it — pushes to
    # feature branches are ignored.
    branches: [main]

  # Run when a pull request is opened, updated, or reopened against "main".
  # This lets you catch problems before code is merged.
  pull_request:
    branches: [main]

# "jobs" defines the actual work to perform. Each job runs in its own
# fresh virtual machine (called a "runner") on GitHub's servers.
# Jobs run in PARALLEL by default unless you add dependencies between them.
# This workflow defines three independent jobs: shellcheck, build, and syntax.
jobs:

  # ---------------------------------------------------------------------------
  # Job 1: shellcheck
  # Purpose: Run ShellCheck, a static analysis tool that finds bugs, style
  #          issues, and potential problems in shell scripts WITHOUT executing
  #          them. Think of it like a spell-checker but for bash code.
  # ---------------------------------------------------------------------------
  shellcheck:
    # "runs-on" specifies the operating system for the virtual machine.
    # "ubuntu-latest" means the newest Ubuntu Linux version GitHub offers.
    # Every job needs this — it tells GitHub what kind of machine to spin up.
    runs-on: ubuntu-latest

    # "steps" is an ordered list of actions to perform inside the job.
    # Each step runs sequentially (one after another) in the same VM.
    steps:
      # "uses" runs a pre-built action from the GitHub Actions marketplace.
      # actions/checkout@v4 clones your repository into the runner so
      # subsequent steps can access your code. Almost every workflow starts
      # with this step. "@v4" pins it to version 4 of the action.
      - uses: actions/checkout@v4

      # "name" is a human-readable label shown in the GitHub Actions UI.
      # "run" executes a shell command on the runner.
      # "sudo" runs the command as root (needed to install system packages).
      # "apt-get install -y" installs a package; "-y" auto-confirms the prompt.
      - name: Install shellcheck
        run: sudo apt-get install -y shellcheck

      # Run shellcheck against all shell scripts in the project.
      # The glob patterns (*.sh) expand to match all .sh files in each directory:
      #   - scripts/*.sh        — shared library and template scripts
      #   - claude-sandbox-dev.sh — the main dev CLI script
      #   - tests/*.sh          — test scripts
      # If any script has issues, shellcheck exits with a non-zero code,
      # which causes this step (and the entire job) to fail.
      - name: Run shellcheck
        run: shellcheck scripts/*.sh claude-sandbox-dev.sh tests/*.sh

  # ---------------------------------------------------------------------------
  # Job 2: build
  # Purpose: Verify the Docker image builds successfully and that the Claude
  #          Code binary is correctly installed inside the resulting container.
  #          This catches Dockerfile errors, missing files, and broken installs.
  # ---------------------------------------------------------------------------
  build:
    runs-on: ubuntu-latest
    steps:
      # Clone the repo (same as above — each job gets its own fresh VM,
      # so every job needs its own checkout step).
      - uses: actions/checkout@v4

      # Build the Docker image from the Dockerfile in the current directory (".").
      # "-t claude-sandbox" tags (names) the resulting image so we can
      # reference it by name in later steps. "docker build" reads the
      # Dockerfile, executes each instruction, and produces a container image.
      - name: Build Docker image
        run: docker build -t claude-sandbox .

      # Start a container from the image and pass "--version" as an argument.
      # "--rm" automatically removes the container after it exits (cleanup).
      # "|| true" means: if the command fails, treat it as success anyway.
      # This is needed because Claude Code may exit non-zero when not
      # authenticated, but we still want to verify the binary is callable.
      # The purpose is to confirm the binary exists and can start at all.
      - name: Verify Claude binary accessible
        run: docker run --rm claude-sandbox --version || true


  # ---------------------------------------------------------------------------
  # Job 3: syntax
  # Purpose: Verify all shell scripts are syntactically valid bash.
  #          This catches typos, unclosed quotes, missing keywords (fi, done),
  #          and other parse errors without actually running the scripts.
  # ---------------------------------------------------------------------------
  syntax:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # "bash -n" is bash's built-in syntax check mode. The "-n" flag tells
      # bash to read and parse the script but NOT execute it. If the script
      # has syntax errors (e.g., missing "fi", unmatched quotes), bash exits
      # with a non-zero code and prints the error.
      #
      # The "run: |" syntax (pipe character) starts a multi-line shell command.
      # Without it, YAML would treat everything as a single line.
      #
      # The "for" loop iterates over every .sh file in scripts/, the dev CLI,
      # and tests/. "echo" prints which file is being checked (useful for
      # debugging if a check fails). If any file has a syntax error, "bash -n"
      # returns non-zero, which causes the step and job to fail.
      - name: Bash syntax check
        run: |
          for f in scripts/*.sh claude-sandbox-dev.sh tests/*.sh; do
            echo "Checking $f..."
            bash -n "$f"
          done
